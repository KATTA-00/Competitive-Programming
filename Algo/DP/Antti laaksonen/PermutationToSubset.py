def minimumRides(x, weights):
    n = len(weights)
    # create a list with 2^n identical pairs [(minimum rides, minimum weight))]
    best = [(n + 1, 0)] * (1 << n) 
    best[0] = (1, 0)

    for s in range(1, 1 << n):
        best[s] = (n + 1, 0)
        for p in range(n):
            # checks if the p-th bit in s is 1 or 0.
            if s & (1 << p):
                # calculates a new subset by removing person p from the current subset s. 
                # The bitwise XOR (^) operation is used for this purpose.
                option = best[s ^ (1 << p)]
                if option[1] + weights[p] <= x:
                    option = (option[0], option[1] + weights[p])
                else:
                    option = (option[0] + 1, weights[p])
                best[s] = min(best[s], option)

    return best[(1 << n) - 1][0]

# Example usage
x = 12
weights = [2, 3, 4, 5, 9, 8]
result = minimumRides(x, weights)
print(result)  # Output: 2

'''
• The expression `s & (1 << p)` is a bitwise operation used to check if person `p` is in the current subset `s`.

• s is the binary representation of the current subset of people. Each bit in s corresponds to a person, 
  with the rightmost bit representing the first person, the next bit representing the second person, 
  and so on. If a bit is set to 1, it means the person is included in the subset, and 
  if it's set to 0, the person is not in the subset.

• s & (1 << p) performs a bitwise AND operation between the binary representation of the current subset s 
  and the binary number generated by 1 << p. This operation checks if the p-th bit in s is 1 or 0.


'''
#----------------------------------------------------------------------------------------------
# code with comments
def minimumRides(x, weights):
    n = len(weights)
    # Create an array 'best' to store the minimum rides and minimum weight for each subset.
    best = [(n + 1, 0)] * (1 << n)
    # Initialize the value for the empty subset (no one has taken a ride yet).
    best[0] = (1, 0)

    for s in range(1, 1 << n):
        best[s] = (n + 1, 0)  # Initialize the minimum rides to a large value and minimum weight to 0.
        for p in range(n):
            if s & (1 << p):
                # If person p is in the current subset (s), consider them for the next ride.
                option = best[s ^ (1 << p)]  # Option is the best solution for the remaining people.
                if option[1] + weights[p] <= x:
                    # If adding person p to the current ride doesn't exceed the weight limit, update the option.
                    option = (option[0], option[1] + weights[p])
                else:
                    # If adding person p exceeds the weight limit, reserve a new ride for p.
                    option = (option[0] + 1, weights[p])
                best[s] = min(best[s], option)  # Update the best solution for the current subset.

    return best[(1 << n) - 1][0]  # Return the minimum number of rides for all people.

# Example usage
x = 12
weights = [2, 3, 4, 5, 9]
result = minimumRides(x, weights)
print(result)  # Output: 2 (minimum rides needed)









